<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body></body>
  <script>
    let width = window.innerWidth;
    let height = window.innerHeight;

    // console.log(height);

    // 起别名方便后面使用
    const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite;

    // 创建一个物理引擎
    const engine = Engine.create();
    // engine.gravity.y = 9.8; // 设置重力
    // 创建一个渲染器
    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        // wireframes: false, // required for images
        // wireframes: true, // 线框模式
        width: width,
        height: height,
        pixelRatio: 1, // 设置像素比
        background: "#fafafa", // 全局渲染模式时背景色
        wireframeBackground: "#222", // 线框模式时背景色
        hasBounds: false,
        showSleeping: false, // 刚体睡眠状态
        showDebug: false, // Debug 信息
        showBroadphase: false, // 粗测阶段
        showBounds: false, // 刚体的界限
        showVelocity: false, // 移动刚体时速度
        showCollisions: false, // 刚体碰撞点
        showSeparations: false, // 刚体分离
        showAxes: false, // 刚体轴线
        showPositions: false, // 刚体位置
        showAngleIndicator: false, // 刚体转角指示
        showIds: false, // 显示每个刚体的 ID
        showVertexNumbers: false, // 刚体顶点数
        showConvexHulls: false, // 刚体凸包点
        showInternalEdges: false, // 刚体内部边界
        showMousePosition: false, // 鼠标约束线
      },
    });

    let conf = {
      restitution: 0.8,
      render: {
        sprite: {
          texture: `http://placekitten.com/100/100`,
        },
      },
    };
    let r = 80;
    // 创建一个方块和一个地面
    // var box = Bodies.rectangle(width / 2, 200, r, r, conf);
    var box = Bodies.polygon(width / 2, 200, 15, r, conf);

    let face = { x: -0.1, y: 0.9 };
    Matter.Body.applyForce(box, box.position, face);

    let rect = {
      x: width / 2,
      y: 100,
      w: 600,
      h: 500,
    };
    rect = {
      x: 0,
      y: 0,
      w: width,
      h: height,
    };

    let d = 50;

    var groundBottom = Bodies.rectangle(
      rect.x,
      rect.y + rect.h,
      rect.w * 2,
      d,
      {
        isStatic: true,
        render: {
          fillStyle: "#cccccc",
        },
      }
    );
    var groundLeft = Bodies.rectangle(rect.x, rect.y + rect.h / 2, d, rect.h, {
      isStatic: true,
      render: {
        fillStyle: "#cccccc",
      },
    });
    var groundRight = Bodies.rectangle(
      rect.x + rect.w,
      rect.y + rect.h / 2,
      d,
      rect.h,
      {
        isStatic: true,
        render: {
          fillStyle: "#cccccc",
        },
      }
    );

    var groundUp = Bodies.rectangle(rect.x, rect.y, rect.w * 2, d, {
      isStatic: true,
      render: {
        fillStyle: "#cccccc",
      },
    });
    // 将他们加入到这个物理引擎中
    Composite.add(engine.world, [
      groundBottom,
      groundLeft,
      groundRight,
      groundUp,
    ]);
    Composite.add(engine.world, [box]);

    // 运行这个渲染器
    Render.run(render);

    // 创建一个运行环境，类似于U3D的Update函数
    var runner = Runner.create();

    // 开始渲染运行
    Runner.run(runner, engine);

    let count = 0;

    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        let box = Bodies.rectangle(width / 2, 200, r, r, conf);
        face.x = face.x + 0.02 * i;
        Matter.Body.applyForce(box, box.position, face);
        Composite.add(engine.world, [box]);
      }, i * 100);
    }
  </script>
</html>
